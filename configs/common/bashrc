# vi: set ft=sh expandtab tabstop=4 shiftwidth=4:
test -z "${bashrc_guard:-}" || return 0
bashrc_guard=1
interactive=
iecho() { true ; }
case $- in
*i*)
    interactive=1
    iecho() { echo "$@" ; }
    ;;
esac
iecho ".bashrc"

have() { type -- "$@" >/dev/null 2>&1 ; }

# Use vi mode readline instead of emacs style
#set -o vi

# To do with resizing and redrawing terminals XXX explain
shopt -s checkwinsize

# core dumps
ulimit -c unlimited
iecho "Set core dump limit to $(ulimit -c)."


HOSTS="redeye work marrakesh maths netsoc" ; export HOSTS

GIT_BASE_DIR="${HOME}/work" ; export GIT_BASE_DIR

ENCRYPTED_BASE_DIR="${HOME}/.encrypted" ; export ENCRYPTED_BASE_DIR
ENCRYPTED_DIR="${HOME}/encrypted" ; export ENCRYPTED_DIR

UNAME="$(uname 2>/dev/null || true)"

# since i'm definitely setting options, start off with at least '-'
LESS="${LESS--}"
if ! echo "$LESS" | grep -Fq 'F' ; then LESS="${LESS}F" ; fi
if ! echo "$LESS" | grep -Fq 'X' ; then LESS="${LESS}X" ; fi
if ! echo "$LESS" | grep -Fq 'R' ; then LESS="${LESS}R" ; fi
export LESS

if test -n "$interactive" ; then
    v_="${PATH:-}"
    if ! echo "$v_" | grep -q '\(^\.:\|:\.:\|:\.$\|^\.$\)' ; then
        PATH="${v_}${v_:+:}." ; export PATH
    fi
fi
v_="${PATH:-}"
n_="${HOME}/bin"
if (test -d "$n_") && (! echo "$v_" | grep -Fq "$n_") ; then
    PATH="${v_}${v_:+:}$n_" ; export PATH
fi

HOME_PREFIX="${HOME}/.local/usr" ; export HOME_PREFIX
if test -d "${HOME_PREFIX}" ; then
    v_="${PATH:-}"
    n_="${HOME_PREFIX}/sbin"
    if (test -d "$n_") && (! echo "$v_" | grep -Fq "$n_") ; then
        PATH="${n_}${v_:+:}${v_}" ; export PATH
    fi
    v_="${PATH:-}"
    n_="${HOME_PREFIX}/bin"
    if (test -d "$n_") && (! echo "$v_" | grep -Fq "$n_") ; then
        PATH="${n_}${v_:+:}${v_}" ; export PATH
    fi
fi
unset v_
unset n_

# XDG
# http://standards.freedesktop.org/basedir-spec/
if ! test -f "/etc/SuSE-release" ; then
    v_="${XDG_DATA_HOME:-}"
    XDG_DATA_HOME="${v_}${v_:+:}${HOME}/.local/share"
    export XDG_DATA_HOME
    v_="${XDG_DATA_DIRS:-}"
    XDG_DATA_DIRS="${v_}${v_:+:}/usr/local/share/:/usr/share/"
    export XDG_DATA_DIRS
    v_="${XDG_CONFIG_HOME:-}"
    XDG_CONFIG_HOME="${v_}${v_:+:}${HOME}/.config"
    export XDG_CONFIG_HOME
    v_="${XDG_CONFIG_DIRS:-}"
    XDG_CONFIG_DIRS="${v_}${v_:+:}/etc/xdg"
    export XDG_CONFIG_DIRS
    unset v_
fi

if (test -d "${HOME}/.cabal") && (! echo "${PATH:-}" | grep -Fq "${HOME}/.cabal/bin") ; then
    PATH="${PATH:+${HOME}/.cabal/bin}${PATH:+:}${PATH:-}"
    export PATH
fi

if (have ruby) && (test -d "${HOME}/.gem") \
&& (have awk) && (have sed) ; then
    if test -z "${RUBY_VERSION:-}" ; then
        RUBY_VERSION="$(ruby --version | awk ' { print $2 } ' | sed -e 's/\.[0-9][0-9]*$//')"
        export RUBY_VERSION
    fi
    n_="${HOME}/.gem/ruby/${RUBY_VERSION}/bin"
    v_="${PATH:-}"
    if (test -d "$n_") && (! echo "$v_" | grep -Fq "$n_") ; then
        PATH="${n_}${v_:+:}${v_}" ; export PATH
    fi
    unset v_
fi
v_="${PYTHONPATH:-}"
PYTHONPATH="${v_}${v_:+:}${HOME}/share/python/lib/python"
export PYTHONPATH
unset v_

unset HISTFILE
HISTSIZE="30" ; export HISTSIZE

if have less ; then
    PAGER="less" ; export PAGER
fi
if have vim ; then
    EDITOR="vim" ; export EDITOR
    VISUAL="$EDITOR" ; export VISUAL
fi
if have google-chrome ; then
    BROWSER="google-chrome" ; export BROWSER
elif have iceweasel ; then
    BROWSER="iceweasel" ; export BROWSER
elif have firefox ; then
    BROWSER="firefox" ; export BROWSER
fi

if have gvim ; then
    CONSOLE_EDITOR="$EDITOR" ; export CONSOLE_EDITOR
    VISUAL_EDITOR="gvim" ; export VISUAL_EDITOR
fi

SCREEN_SHELL="$(which bash)" ; export SCREEN_SHELL

if test -n "$interactive" ; then
    KEYCHAIN_DIR="${HOME}/.keychain" ; export KEYCHAIN_DIR
    if test ! -d "$KEYCHAIN_DIR" ; then
        if test ! -e "$KEYCHAIN_DIR" ; then
            mkdir -p "$KEYCHAIN_DIR"
        fi
    fi
    if test -d "$KEYCHAIN_DIR" ; then
        if have keychain ; then
            iecho "Starting keychain."
            keychain --nogui --quiet --timeout 4800
            for bashrc_key_type in "sh" "sh-gpg" ; do
                if test -r "${KEYCHAIN_DIR}/${HOSTNAME}-${bashrc_key_type}" ; then
                    iecho "Sourcing \"${KEYCHAIN_DIR}/${HOSTNAME}-${bashrc_key_type}\""
                    . "${KEYCHAIN_DIR}/${HOSTNAME}-${bashrc_key_type}"
                fi
            done
            unset bashrc_key_type
        fi
    fi
    if have tty ; then
        GPG_TTY=$(tty) ; export GPG_TTY
    fi
fi

FULLNAME="Gavin Beatty" ; export FULLNAME
EMAIL="gavinbeatty@gmail.com" ; export EMAIL

GPG_KEY_ID="Gavin Beatty (Dublin, Ireland) <gavinbeatty@gmail.com>"
export GPG_KEY_ID

DEBFULLNAME="${FULLNAME}" ; export DEBFULLNAME
DEBEMAIL="${EMAIL}" ; export DEBEMAIL
GIT_AUTHOR_NAME="${FULLNAME}" ; export GIT_AUTHOR_NAME
GIT_AUTHOR_EMAIL="${EMAIL}" ; export GIT_AUTHOR_EMAIL
BZR_EMAIL="${FULLNAME} <${EMAIL}>" ; export BZR_EMAIL

if test -n "$interactive" ; then
    if test -r "${HOME}/.git-completion.bash" ; then
        . "${HOME}/.git-completion.bash"
    else
    # taken from git/contrib/completion/git-completion.bash
    #
    # __git_ps1 accepts 0 or 1 arguments (i.e., format string)
    # returns text to add to bash PS1 prompt (includes branch name)
    __git_ps1 () {
        local g="$(git rev-parse --git-dir 2>/dev/null)"
        if [ -n "$g" ]; then
            local r
            local b
            if [ -d "$g/rebase-apply" ]
            then
                if test -f "$g/rebase-apply/rebasing"
                then
                    r="|REBASE"
                elif test -f "$g/rebase-apply/applying"
                then
                    r="|AM"
                else
                    r="|AM/REBASE"
                fi
                b="$(git symbolic-ref HEAD 2>/dev/null)"
            elif [ -f "$g/rebase-merge/interactive" ]
            then
                r="|REBASE-i"
                b="$(cat "$g/rebase-merge/head-name")"
            elif [ -d "$g/rebase-merge" ]
            then
                r="|REBASE-m"
                b="$(cat "$g/rebase-merge/head-name")"
            elif [ -f "$g/MERGE_HEAD" ]
            then
                r="|MERGING"
                b="$(git symbolic-ref HEAD 2>/dev/null)"
            else
                if [ -f "$g/BISECT_LOG" ]
                then
                    r="|BISECTING"
                fi
                if ! b="$(git symbolic-ref HEAD 2>/dev/null)"
                then
                    if ! b="$(git describe --exact-match HEAD 2>/dev/null)"
                    then
                        b="$(cut -c1-7 "$g/HEAD")..."
                    fi
                fi
            fi

            local w
            local i

            if test -n "${GIT_PS1_SHOWDIRTYSTATE-}"; then
                if test "$(git config --bool bash.showDirtyState)" != "false"; then
                    git diff --no-ext-diff --ignore-submodules \
                        --quiet --exit-code || w="*"
                    if git rev-parse --quiet --verify HEAD >/dev/null; then
                        git diff-index --cached --quiet \
                            --ignore-submodules HEAD -- || i="+"
                    else
                        i="#"
                    fi
                fi
            fi

            if [ -n "${1-}" ]; then
                printf "$1" "${b##refs/heads/}$w$i$r"
            else
                printf " (%s)" "${b##refs/heads/}$w$i$r"
            fi
        fi
    }
    fi

    if (test \! "x${TERM}" = 'xdumb') && (test -n "$BASH") && (test -n "$PS1") ; then
        if test "x$(/usr/bin/id -u)" = 'x0' ; then
            PS1='\[\e[01;31m\]\h \[\e[01;34m\]\w \[\e[1;32m\]\$\[\e[00m\] '
            export PS1
        else
            PS1='\[\e[01;32m\]\u\[\e[1;37m\]@\[\e[0m\]\[\e[01;32m\]\h\[\e[01;34m\]\w\[\e[01;31m\]$(__git_ps1 "(%s)")\[\e[1;32m\]\$\[\e[00m\] '
            export PS1
        fi
    fi
fi

# line-wrap minicom by default
MINICOM="${MINICOM:-}"
if ! echo "$MINICOM" | grep -q -- '-[a-zA-Z0-9]*w' ; then
    MINICOM="${MINICOM}${MINICOM:+ }-w" ; export MINICOM
fi
if ! echo "$MINICOM" | grep -q -- '-[a-zA-Z0-9]*c +on' ; then
    MINICOM="${MINICOM}${MINICOM:+ }-c on" ; export MINICOM
fi

########################################################################
# Per box
########################################################################
for i_ in $HOSTS ; do
    if test -r "${HOME}/.bashrc.${i_}" ; then
        . "${HOME}/.bashrc.${i_}"
    fi
done
unset i_
########################################################################
# Per system
########################################################################
if echo "$UNAME" | grep -Fiq 'darwin' ; then
    if test -r "${HOME}/.bashrc.darwin" ; then
        . "${HOME}/.bashrc.darwin"
    fi
fi
# XXX how to detect msys/mingw properly? what's the difference?
if (test x"$MSYSTEM" = x"MINGW32") || (test x"$OSTYPE" = x"msys") ; then
    if test -r "${HOME}/.bashrc.msys" ; then
        . "${HOME}/.bashrc.msys"
    fi
fi

########################################################################
# Per interactive feature
########################################################################
if test -n "$interactive" ; then
    if test -r /etc/bash_completion ; then
        # /etc/bash_completion sources ${HOME}/.bash_completion for us
        . /etc/bash_completion
    else
        . "${HOME}/.bash_completion"
    fi

    if test -r "${HOME}/.cdargs.bash" ; then
        . "${HOME}/.cdargs.bash"
    fi
    for i_ in functions aliases ; do
        if test -r "${HOME}/.bashrc.${i_}" ; then
            . "${HOME}/.bashrc.${i_}"
        fi
    done
fi
