# vi: set ft=sh expandtab tabstop=4 shiftwidth=4:
test -z "${bashrc_guard:-}" || return 0
bashrc_guard=1

case $- in
*i*) isinteractive=1 ; iecho() { echo "$@" ; } ;;
*) isinteractive=0 ; iecho() { true ; } ;;
esac
iecho ".bashrc"
# XXX perhaps use this to add to PATH etc.
regexelem() { echo "$2" | grep -q "\(^${1}:\\|:${1}:\\|:${1}\$\\|^${1}\$\)" ; }

if test "$isinteractive" -ne 0 ; then
    cat -- /tmp/gavinbeatty-du.log 2>/dev/null || true
    if type -- df >/dev/null 2>&1 ; then
        df -h
    fi
fi

########################################################################
# Options
########################################################################
if test -r ~/.bashrc.options.sh ; then
    . ~/.bashrc.options.sh
fi
if test "${BASHRC_OPTION_ETC_BASHRC:-0}" -ne 0 ; then
    if test -r /etc/bashrc ; then
        . /etc/bashrc
    fi
fi
if test -n "${BASHRC_OPTION_LC_ALL:-}" ; then
    LC_ALL="$BASHRC_OPTION_LC_ALL" ; export LC_ALL
fi
if test -n "${BASHRC_OPTION_LANG:-}" ; then
    LANG="$BASHRC_OPTION_LANG" ; export LANG
fi

# Use vi mode readline instead of emacs style
#set -o vi

# To do with resizing and redrawing terminals XXX explain
shopt -s checkwinsize

# core dumps
ulimit -c unlimited
iecho "ulimit -c $(ulimit -c)"
# get rid of nosy others
# 0027 => 'u=rwx,g=rx,o='
umask 0027
iecho "umask $(umask)"

########################################################################
# Set variables that have no dependency on PATH etc.
########################################################################
UNAME="$(uname 2>/dev/null || true)"
HOSTS="redeye work marrakesh maths netsoc" ; export HOSTS

HISTSIZE="30" ; export HISTSIZE

FULLNAME="Gavin Beatty" ; export FULLNAME
EMAIL="gavinbeatty@gmail.com" ; export EMAIL
DEBFULLNAME="${FULLNAME}" ; export DEBFULLNAME
DEBEMAIL="${EMAIL}" ; export DEBEMAIL
GIT_AUTHOR_NAME="${FULLNAME}" ; export GIT_AUTHOR_NAME
GIT_AUTHOR_EMAIL="${EMAIL}" ; export GIT_AUTHOR_EMAIL
BZR_EMAIL="${FULLNAME} <${EMAIL}>" ; export BZR_EMAIL
GPG_KEY_ID="Gavin Beatty (Dublin, Ireland) <gavinbeatty@gmail.com>"

# since i'm definitely setting options, start off with at least '-'
LESS="${LESS:--}"
if ! echo "$LESS" | grep -Fq 'F' ; then LESS="${LESS}F" ; fi
if ! echo "$LESS" | grep -Fq 'X' ; then LESS="${LESS}X" ; fi
if ! echo "$LESS" | grep -Fq 'R' ; then LESS="${LESS}R" ; fi
if ! echo "$LESS" | grep -Fq 'S' ; then LESS="${LESS}S" ; fi
export LESS

# line-wrap minicom by default
MINICOM="${MINICOM:-}"
if ! echo "$MINICOM" | grep -q -- '-[a-zA-Z0-9]*w' ; then
    MINICOM="${MINICOM}${MINICOM:+ }-w" ; export MINICOM
fi
if ! echo "$MINICOM" | grep -q -- '-[a-zA-Z0-9]*c +on' ; then
    MINICOM="${MINICOM}${MINICOM:+ }-c on" ; export MINICOM
fi

# XDG
# http://standards.freedesktop.org/basedir-spec/
if ! test -f "/etc/SuSE-release" ; then
    v_="${XDG_DATA_HOME:-}"
    XDG_DATA_HOME="${v_}${v_:+:}${HOME}/.local/share"
    export XDG_DATA_HOME
    v_="${XDG_DATA_DIRS:-}"
    XDG_DATA_DIRS="${v_}${v_:+:}/usr/local/share/:/usr/share/"
    export XDG_DATA_DIRS
    v_="${XDG_CONFIG_HOME:-}"
    XDG_CONFIG_HOME="${v_}${v_:+:}${HOME}/.config"
    export XDG_CONFIG_HOME
    v_="${XDG_CONFIG_DIRS:-}"
    XDG_CONFIG_DIRS="${v_}${v_:+:}/etc/xdg"
    export XDG_CONFIG_DIRS
    unset v_
fi

#v_="${PYTHONPATH:-}"
#PYTHONPATH="${v_}${v_:+:}${HOME}/.local/usr/lib/python"
#pyver_="$(python -V 2>&1 | cut -d' ' -f2 | perl -wne 's/(\d+\.\d+)\..*/$1/;print;')"
#v_="${PYTHONPATH:-}"
#PYTHONPATH="${v_}${v_:+:}${HOME}/.local/usr/lib/python${pyver_}"
#export PYTHONPATH
#unset v_

GIT_BASE_DIR="${HOME}/work" ; export GIT_BASE_DIR

ENCRYPTED_BASE_DIR="${HOME}/.encrypted" ; export ENCRYPTED_BASE_DIR
ENCRYPTED_DIR="${HOME}/encrypted" ; export ENCRYPTED_DIR

########################################################################
# Set PATH and associated variables
########################################################################
if test "${isinteractive:-0}" -ne 0 ; then
    v_="${PATH:-}"
    if ! regexelem '\.' "$v_" ; then
        PATH="${v_}${v_:+:}." ; export PATH
    fi
fi
v_="${PATH:-}"
n_="${HOME}/bin"
if (test -d "$n_") && (! echo "$v_" | grep -Fq "$n_") ; then
    PATH="${v_}${v_:+:}$n_" ; export PATH
fi

HOME_PREFIX="${HOME}/.local/usr" ; export HOME_PREFIX
if test -d "${HOME_PREFIX}" ; then
    v_="${PATH:-}"
    n_="${HOME_PREFIX}/sbin"
    if (test -d "$n_") && (! echo "$v_" | grep -Fq "$n_") ; then
        PATH="${n_}${v_:+:}${v_}" ; export PATH
    fi
    v_="${PATH:-}"
    n_="${HOME_PREFIX}/bin"
    if (test -d "$n_") && (! echo "$v_" | grep -Fq "$n_") ; then
        PATH="${n_}${v_:+:}${v_}" ; export PATH
    fi
fi
n_="${HOME}/.cabal/bin"
v_=
test -z "${PATH:-}" || v_=":$PATH"
if (test -d "${HOME}/.cabal") && (! echo "$v_" | grep -Fq "$n_") ; then
    PATH="${n_}${v_}" ; export PATH
fi

if (type -- ruby >/dev/null 2>&1) && (test -d "${HOME}/.gem") \
&& (type -- awk >/dev/null 2>&1) && (type -- sed >/dev/null 2>&1) ; then
    if test -z "${RUBY_VERSION:-}" ; then
        RUBY_VERSION="$(ruby --version | awk ' { print $2 } ' | sed -e 's/\.[0-9][0-9]*$//')"
    fi
    n_="${HOME}/.gem/ruby/${RUBY_VERSION}/bin"
    v_="${PATH:-}"
    if (test -d "$n_") && (! echo "$v_" | grep -Fq "$n_") ; then
        PATH="${n_}${v_:+:}${v_}" ; export PATH
    fi
    unset v_
fi
unset v_
unset n_

########################################################################
# Set anything depending on PATH etc.
########################################################################
if type -- less >/dev/null 2>&1 ; then
    PAGER="less" ; export PAGER
fi

for i_ in vim nano pico ; do
    if type -- "$i_" >/dev/null 2>&1 ; then
        VISUAL="$i_" ; export VISUAL
        break
    fi
done
unset i_
EDITOR="${VISUAL:-}" ; export EDITOR
SVN_EDITOR="${VISUAL:-}" ; export SVN_EDITOR
if type -- google-chrome >/dev/null 2>&1 ; then
    BROWSER="google-chrome" ; export BROWSER
elif type -- iceweasel >/dev/null 2>&1 ; then
    BROWSER="iceweasel" ; export BROWSER
elif type -- firefox >/dev/null 2>&1 ; then
    BROWSER="firefox" ; export BROWSER
fi

if test "${isinteractive:-0}" -ne 0 ; then
    if type -- keychain >/dev/null 2>&1 ; then
        KEYCHAIN_DIR="${HOME}/.keychain"
        if test ! -d "$KEYCHAIN_DIR" ; then
            if test ! -e "$KEYCHAIN_DIR" ; then
                mkdir -p "$KEYCHAIN_DIR"
            fi
        fi
        if test -d "$KEYCHAIN_DIR" ; then
            iecho "keychain..."
            keychain --nogui --quiet --timeout 4800
            for i_ in "sh" "sh-gpg" ; do
                if test -r "${KEYCHAIN_DIR}/${HOSTNAME}-${i_}" ; then
                    iecho "${HOSTNAME}-${i_}"
                    . "${KEYCHAIN_DIR}/${HOSTNAME}-${i_}"
                fi
            done
            unset i_
        fi
    fi
    if type -- tty >/dev/null 2>&1 ; then
        GPG_TTY=$(tty) ; export GPG_TTY
    fi
fi

if test "${isinteractive:-0}" -ne 0 ; then
    if test -r "${HOME}/.git-completion.bash" ; then
        . "${HOME}/.git-completion.bash"
    else
    # taken from git/contrib/completion/git-completion.bash
    #
    # __git_ps1 accepts 0 or 1 arguments (i.e., format string)
    # returns text to add to bash PS1 prompt (includes branch name)
    __git_ps1() {
        local g="$(git rev-parse --git-dir 2>/dev/null)"
        if [ -n "$g" ]; then
            local r
            local b
            if [ -d "$g/rebase-apply" ]
            then
                if test -f "$g/rebase-apply/rebasing"
                then
                    r="|REBASE"
                elif test -f "$g/rebase-apply/applying"
                then
                    r="|AM"
                else
                    r="|AM/REBASE"
                fi
                b="$(git symbolic-ref HEAD 2>/dev/null)"
            elif [ -f "$g/rebase-merge/interactive" ]
            then
                r="|REBASE-i"
                b="$(cat "$g/rebase-merge/head-name")"
            elif [ -d "$g/rebase-merge" ]
            then
                r="|REBASE-m"
                b="$(cat "$g/rebase-merge/head-name")"
            elif [ -f "$g/MERGE_HEAD" ]
            then
                r="|MERGING"
                b="$(git symbolic-ref HEAD 2>/dev/null)"
            else
                if [ -f "$g/BISECT_LOG" ]
                then
                    r="|BISECTING"
                fi
                if ! b="$(git symbolic-ref HEAD 2>/dev/null)"
                then
                    if ! b="$(git describe --exact-match HEAD 2>/dev/null)"
                    then
                        b="$(cut -c1-7 "$g/HEAD")..."
                    fi
                fi
            fi

            local w
            local i

            if test -n "${GIT_PS1_SHOWDIRTYSTATE-}"; then
                if test "$(git config --bool bash.showDirtyState)" != "false"; then
                    git diff --no-ext-diff --ignore-submodules \
                        --quiet --exit-code || w="*"
                    if git rev-parse --quiet --verify HEAD >/dev/null; then
                        git diff-index --cached --quiet \
                            --ignore-submodules HEAD -- || i="+"
                    else
                        i="#"
                    fi
                fi
            fi

            if [ -n "${1-}" ]; then
                printf "$1" "${b##refs/heads/}$w$i$r"
            else
                printf " (%s)" "${b##refs/heads/}$w$i$r"
            fi
        fi
    }
    fi

fi
svn_ps1_() {
    local v="$(LC_ALL=C ${SVN_EXE:-svn} info 2>/dev/null)"
    if test $? -eq 0 ; then
        v="$(echo "$v" | perl -wne 'if(/^URL: .*\/(trunk|tags|branches)(\/|$)/){s!^.*/(trunk|tags|branches)((/[^/]*)?).*!$1$2!;s/^trunk.*/trunk/;print;}')"
        if test -n "$v" ; then printf "$1" "$v" && return 0 ; fi
    fi
    return 1
}
ps1_() {
    local i=
    for i in __git_ps1 svn_ps1_ ; do
        local v="$("$i" "$@")"
        if test -n "$v" ; then echo "$v" && break ; fi
    done
}
export -f ps1_
PS1_ROOT='\[\e[01;31m\]\h \[\e[01;34m\]\w \[\e[1;32m\]\$\[\e[00m\] '
export PS1_ROOT
PS1_ROOT_NOCOLOR='\h:\w\$ '
export PS1_ROOT_NOCOLOR
#PS1_FUNC='\[\e[01;32m\]\u\[\e[1;37m\]@\[\e[0m\]\[\e[01;32m\]\h\[\e[01;34m\]\w\[\e[01;31m\]$(ps1_ "(%s)")\[\e[1;32m\]\$\[\e[00m\] '
PS1_FUNC='\[\e[0;32m\]\u\[\e[m\]@\[\e[1;34m\]\h\[\e[m\]:\[\e[0;37m\]\w\[\e[m\]$(ps1_ "\[\e[1;31m\](%s)\[\e[m\]")\$ '
export PS1_FUNC
#PS1_NOFUNC='\[\e[01;32m\]\u\[\e[1;37m\]@\[\e[0m\]\[\e[01;32m\]\h\[\e[01;34m\]\w\[\e[01;31m\]\[\e[1;32m\]\$\[\e[00m\] '
PS1_NOFUNC='\[\e[0;32m\]\u\[\e[m\]@\[\e[1;34m\]\h\[\e[m\]:\[\e[0;37m\]\w\[\e[m\]\$ '
export PS1_NOFUNC
PS1_NOCOLOR='\u@\h:\w\$ '
export PS1_NOCOLOR
if test "${TERM:-}" != 'dumb' && test -n "${BASH:-}" ; then
    if test "$(/usr/bin/id -u)" = '0' ; then
        PS1="$PS1_ROOT" ; export PS1
    else
        PS1="$PS1_FUNC" ; export PS1
    fi
elif test "${isinteractive:-0}" -ne 0 ; then
    PS1="$PS1_NOCOLOR" ; export PS1
fi
SUDO_PS1="$PS1_NOCOLOR" ; export SUDO_PS1

########################################################################
# Per box
########################################################################
for i_ in $HOSTS ; do
    if test -r "${HOME}/.bashrc.${i_}.sh" ; then
        . "${HOME}/.bashrc.${i_}.sh"
    fi
done
unset i_
########################################################################
# Per system
########################################################################
if echo "$UNAME" | grep -Fiq 'darwin' ; then
    if test -r "${HOME}/.bashrc.darwin.sh" ; then
        . "${HOME}/.bashrc.darwin.sh"
    fi
fi
# XXX how to detect msys/mingw properly? what's the difference?
if (test x"$MSYSTEM" = x"MINGW32") || (test x"$OSTYPE" = x"msys") ; then
    if test -r "${HOME}/.bashrc.msys.sh" ; then
        . "${HOME}/.bashrc.msys.sh"
    fi
fi

########################################################################
# Per interactive feature
########################################################################
if test "${isinteractive:-0}" -ne 0 ; then
    if test -r /etc/bash_completion ; then
        # /etc/bash_completion sources ${HOME}/.bash_completion for us
        . /etc/bash_completion
    elif test -r "${HOME}/.bash_completion"
        . "${HOME}/.bash_completion"
    fi

    if test -r "${HOME}/.cdargs.bash" ; then
        . "${HOME}/.cdargs.bash"
    fi
    for i_ in func alias ; do
        if test -r "${HOME}/.bashrc.${i_}.sh" ; then
            . "${HOME}/.bashrc.${i_}.sh"
        fi
    done
fi
