#!/bin/sh
# vi: set ft=sh expandtab shiftwidth=4 tabstop=4:
set -e
set -u
trap ' echo Caught SIGINT >&2 ; exit 1 ; ' INT
trap ' echo Caught SIGTERM >&2 ; exit 1 ; ' TERM
trap ' echo Unexpected exit >&2 ; exit 1 ; ' 0
prog="$(basename -- "$0")"
subprog="${prog##git-}"
niceprog="git $subprog"
test "$prog" != "$subprog" || niceprog="$prog"
die() { trap '' 0 ; echo "error: $@" >&2 ; exit 1 ; }
udie() { trap '' 0 ; usage >&2 ; echo "error: $@" >&2 ; exit 1 ; }
pax() { trap '' 0 ; exit 0 ; }
usage() {
    cat <<EOF
usage: $niceprog [options] -- [<command>]
    -n, --dry-run   print only the final command, but don't execute it
    -v, --verbose   print and execute
    -r, --remote    find changes from remote not in local (HEAD..remote) (default)
    -l, --local     find changes from local not in remote (remote..HEAD) (reverses)
    -N, --news      news in b since last merge base (HEAD..remote) (default)
    -d, --diff      all differences since last merge base (HEAD...remote) (bidirectional)
EOF
}
testrun=
verbose=
reverse=
diff=..
extra=
command=
args=0
odone=
arg() {
    if test "$args" -eq 0 ; then args=1 ; command="$1" ; fi
}
while test $# -gt 0 ; do
    if test -z "$odone" ; then
        case "$1" in
            -n|--dry-run) testrun=1 ; verbose=1 ;;
            -v|--verbose) verbose=1 ;;
            -r|--remote) reverse= ;;
            -l|--local) reverse=1 ;;
            -N|--news) diff=.. ; extra= ;;
            -d|--diff) diff=... ; extra="--left-right" ;;
            -h|-\?|--help) usage ; pax ;; # not much point in --help since git catches it
            --) odone=1 ;;
            -[a-z][a-z]*) os="$(echo "${1##-}" | sed 's/./-& /g')" ; shift ; set -- $os "$@" ;;
            -) arg "$1" ;;
            -*) udie "Unrecognized option, $1." ;;
            *) arg "$1" ;;
        esac
    elif test "$args" -eq 0 ; then args=1 ; command="$1"
    else break ; fi
    if test -n "${os:-}" ; then os=
    else shift ; fi
done
go() {
    if test -n "$verbose" ; then echo "$*" ; fi
    if test -z "$testrun" ; then trap '' 0 ; exec "$@" ; fi
}
br="$(git rev-parse --abbrev-ref HEAD)"
if test "$br" = HEAD ; then
    die "Not on any branch so I cannot find the remote branch."
fi
r="$(git config branch."$br".remote)" || die "No remote for $br."
rbr_="$(git config branch."$br".merge)" || die "No remote branch for $br."
rbr="${rbr_##refs/heads/}"
test "$rbr" != "$rbr_" || die "Expected remote branch $rbr_ to be in refs/heads/."
command="${command:-log}"
if test -n "$reverse" ; then
    go git "$command" $extra "$@" "${r}/$rbr"$diff
else
    go git "$command" $extra "$@" $diff"${r}/$rbr"
fi
pax
